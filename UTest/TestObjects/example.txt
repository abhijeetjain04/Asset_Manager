#include <iostream>
#include <fstream>
#include <vector>
#include <bit7z/bit7z.hpp>

int main() {
    try {
        // Define the archive name
        const std::string archiveName = "compressed_assets.7z";

        // Initialize the Bit7z archive
        bit7z::Bit7zArchive archive;

        // Create the archive
        archive.create(archiveName);

        // Define the directory containing the ".tga" assets
        const std::string assetsDir = "assets";

        // Iterate through the ".tga" files in the assets directory
        for (const auto& entry : std::filesystem::directory_iterator(assetsDir)) {
            if (entry.is_regular_file() && entry.path().extension() == ".tga") {
                // Get the file path and name
                const std::string filePath = entry.path().string();
                const std::string fileName = entry.path().filename().string();

                // Add the ".tga" file to the archive
                archive.addFile(filePath, fileName);
            }
        }

        // Finalize and close the archive
        archive.finalize();
        archive.close();

        std::cout << "Compression complete. Archive saved as: " << archiveName << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <vector>
#include <bit7z/bit7z.hpp>

int main() {
    try {
        // Define the archive name
        const std::string archiveName = "compressed_assets.7z";

        // Initialize the Bit7z archive
        bit7z::Bit7zArchive archive;

        // Create the archive
        archive.create(archiveName);

        // Define the directory containing the ".tga" assets
        const std::string assetsDir = "assets";

        // Iterate through the ".tga" files in the assets directory
        for (const auto& entry : std::filesystem::directory_iterator(assetsDir)) {
            if (entry.is_regular_file() && entry.path().extension() == ".tga") {
                // Get the file path and name
                const std::string filePath = entry.path().string();
                const std::string fileName = entry.path().filename().string();

                // Add the ".tga" file to the archive
                archive.addFile(filePath, fileName);
            }
        }

        // Finalize and close the archive
        archive.finalize();
        archive.close();

        std::cout << "Compression complete. Archive saved as: " << archiveName << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <vector>
#include <bit7z/bit7z.hpp>

int main() {
    try {
        // Define the archive name
        const std::string archiveName = "compressed_assets.7z";

        // Initialize the Bit7z archive
        bit7z::Bit7zArchive archive;

        // Create the archive
        archive.create(archiveName);

        // Define the directory containing the ".tga" assets
        const std::string assetsDir = "assets";

        // Iterate through the ".tga" files in the assets directory
        for (const auto& entry : std::filesystem::directory_iterator(assetsDir)) {
            if (entry.is_regular_file() && entry.path().extension() == ".tga") {
                // Get the file path and name
                const std::string filePath = entry.path().string();
                const std::string fileName = entry.path().filename().string();

                // Add the ".tga" file to the archive
                archive.addFile(filePath, fileName);
            }
        }

        // Finalize and close the archive
        archive.finalize();
        archive.close();

        std::cout << "Compression complete. Archive saved as: " << archiveName << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}

Code Test
The Asset Manager
An asset manager is an important tool for many game developers today. Not only to improve the 
organisations workflow, but also to ensure efficiency when managing the many assets required by a 
project. Your task is to write a tool in C++ that can import/manage assets and package them for a 
game. This must be implemented as a stand-alone tool, and you can choose to either implement a 
CLI or GUI interface. 
You may use any language features or standard library functions supported by Visual Studio 2019. If 
you use any other libraries like zlib or frameworks, the build and install process should be automated 
and no manual setup should be required other than pressing build. Make sure to motivate your code 
decisions and library choices in a separate readme file. 
Required functionality:
• Ability to package assets into compressed archives.
• Ability to add/remove assets from archive.
• Ability to retrieve assets from archive.
• Ability to list all assets that have been imported.
• Display asset meta data (e.g. Image resolution, file size, etc)
• File types that are required to be supported are: ‘.tga’, ‘.ogg/wav’, ‘.json’
Scope: • You are not required to implement support for additional file extensions than above.
• You decide on CLI or GUI interface.
• Version control, asset dependencies and licenses are not required.
• You do not need to implement your own compression algorithm; you can use an existing 
library.
Things to consider: • Systems correctness. The system must never end up in an inconsistent state.
o Think also about crashes and error handling.
• What compression to use on the assets.
• Data structures and algorithms used for other functionality.
• Architecture and code clarity.
• Future proofing. How easy it is to extend code functionality. 
• User-friendly. A non-technical person should be able to use your program.
Delivery:
The delivery should consist of a shared link to a zip file uploaded on (any) cloud storage, containing:
• Application source code: You may use either a Visual Studio solution compatible with VS2019 
or a CMake project. The project should build without any errors or warnings on windows.
• Very short documentation: General overview how the problem was solved. Any problems 
you encountered and how they were solved.
Please do not email your solution as an attachment, our mail filter will reject the email